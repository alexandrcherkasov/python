class spine_analizer:
    def __init__(self, img):
        img = cv.imread(img)
        hsv = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        #self.angle = []
        #self.neutral = []
        self.contours = cv.findContours(hsv, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
        self.contours = np.array(self.contours)
        self.contours = self.contours[0] if imutils.is_cv2() else self.contours[1]
        self.lengtn = len(self.contours)
        self.box = np.zeros((self.lengtn, 4, 2))
        self.center = np.zeros((self.lengtn, 2))
        for i in range(self.lengtn):
            cnt = self.contours[i]
            rect = cv.minAreaRect(cnt)
            box = cv.boxPoints(rect)
            #box = np.int0(box)
            #print(type(box),box.shape)
            center, wh, rot = rect
            #center = np.int0(center)
            self.center[i] = center
            #print(type(center),center.shape)
            #rot = np.int0(rot)
            #print(type(rot),rot.shape)
            """Прямоугольники у которых первоначальная координата находится в правом нижнем углу,у них высота больше,чем длина, соответственно таким образом переопределяем эти координаты,меняя их местами"""
            if (wh[1] >= wh[0]):
                tmp0, tmp1, tmp2, tmp3 = box[0].copy(), box[1].copy(), box[2].copy(), box[3].copy()
                #print ('--------------\n',i,box)
                #print (tmp0, tmp1, tmp2, tmp3)
                box[0], box[1], box[2], box[3] = tmp1, tmp2, tmp3, tmp0
                print(box, tmp0)
            self.box[i] = box

    def reduce_box(self, percent):
        # Процедура уменьщает описывающий позвонок прямоугольник на percent проценов по двум измерениям
        # Результат: обновление поля box
        pass

    def delete_box_intersection(self):
        # Процедура устраняет наложения прямоугольников
        # Результат: обновление поля box
        pass

        # Вычисляем наклоны позвонков
    def calculate_angle(self):
        #num = 0
        angles_list = []
        for bx in self.box:
            #cnt = cnts[i]
            #rect = cv.minAreaRect(cnt)
            #box = cv.boxPoints(rect)
            #center, wh, rot = rect
            #print(rot,box,type(box))
            #box_transposed = box.transpose()
            #y_box = box_transposed[1]
            first_point, second_point = bx[0], bx[3]
            down_side_vect = first_point - second_point
            norm = sqrt(down_side_vect[0] ** 2 + down_side_vect[1] ** 2)
            down_side_vect /= norm
            #print('vect',down_side_vect,down_side_vect[1],down_side_vect[1]*180/pi)
            print('vect', down_side_vect[1] * 180 / pi)
            angles_list.append(down_side_vect[1] * 180 / pi)
            #num += 1
        self.angle = np.array(angles_list)
    #print('fisrt second_num',first_point,inum_second_point)
    #box = np.int0(box)
    #center = np.int0(center)
    #rot = np.int0(rot)

    def calculate_neutral_kink(self):
        curr_angle = 0.
        pred_angle = 0.
        neutral_list = []
        kink_list = []
        lneutral = False
        lkink = False
        for i, angle in enumerate(self.angle):
            print(i, angle, math.fabs(pred_angle), math.fabs(angle), not lneutral)
            if i > 0 and not lneutral and math.fabs(pred_angle) > math.fabs(angle):
                neutral_list.append(i - 1)
                lneutral = True
                print('lneutral')
            if i > 0 and lneutral and math.fabs(pred_angle) < math.fabs(angle):
                kink_list.append(i - 1)
                lneutral = False
                print('kink')
                print(lneutral)
            pred_angle = angle
        print(neutral_list, kink_list)
        self.neutral = np.array(neutral_list)
        self.kink = np.array(kink_list)

    def calculate_scoliosis_angle_Kobb(self):
        scoliosis_angle_list = []
        for i in range(len(self.neutral) - 1):
            ilower = self.neutral[i]
            iupper = self.neutral[i + 1]
            print('\n\ni=', i, 'lower, upper = ', ilower, iupper)
            # нижние точки
            fpoint1, fpoint2 = self.box[ilower][0], self.box[ilower][3]
            print('lower points: ', fpoint1, fpoint2)
            # верхние точки
            spoint1, spoint2 = self.box[iupper][1], self.box[iupper][2]
            print('upper points: ', spoint1, spoint2)
            xs1, ys1 = tuple(spoint1)
            xs2, ys2 = tuple(spoint2)
            xf1, yf1 = tuple(fpoint1)
            xf2, yf2 = tuple(fpoint2)
            #print(spoint1,xr1,yr1)
            af = (yf2 - yf1) / (xf2 - xf1)
            bf = yf1 - af * xf1
            print('check1')
            print(yf1, af * xf1 + bf)
            print(yf2, af * xf2 + bf)
            as1 = (ys2 - ys1) / (xs2 - xs1)
            bs1 = ys1 - as1 * xs1
            print('check2')
            print(ys1, as1 * xs1 + bs1)
            print(ys2, as1 * xs2 + bs1)
            x_intersect = (bf - bs1) / (as1 - af)
            y_intersect = af * x_intersect + bf
            intersection_point = np.array([x_intersect, y_intersect])
            print(fpoint1, fpoint2, af, bf)
            print(spoint1, spoint2, as1, bs1)
            print(intersection_point)
            vf = np.array([xf1 - xf2, yf1 - yf2])
            vs = np.array([xs1 - xs2, ys1 - ys2])
            normf = math.sqrt(vf[0] ** 2 + vf[1] ** 2)
            norms = math.sqrt(vs[0] ** 2 + vs[1] ** 2)
            vf /= normf
            vs /= norms
            angle = math.acos(vf[0] * vs[0] + vf[1] * vs[1])
            if angle > pi / 2:
                angle = pi - angle
            print('angle = ', angle, angle * 180 / pi)
            scoliosis_angle_list.append(angle * 180 / pi)
        self.scoliosis_angle_Kobb = np.array(scoliosis_angle_list)

    def calculate_scoliosis_angle_Fergusson(self):
        # Вычисление угла сколиоза по методу Фергюссона
        # Результат: углы, вычисленные по методу Фергюссона
        scoliosis_angle_list = []
        print("MYBOXCENTER=", self.center)
        for i in range(len(self.neutral) - 1):
            ilower = self.neutral[i]
            iupper = self.neutral[i + 1]
            """Определяем центральный позвонок между нижним и верхним нейтральным позвонком"""
            if self.neutral[i]==0:
                icenter = np.round(iupper/2,0)
                icenter = np.round(icenter + ilower,0)
                icenter = np.int0(icenter)
            else:
                icenter = np.round(iupper / ilower, 0)
                icenter = np.round(icenter + ilower, 0)
                icenter = np.int0(icenter)
            """Берём координаты центров """
            dpoint1, dpoint2 = self.center[ilower][0], self.center[ilower][1]
            cpoint1, cpoint2 = self.center[icenter][0], self.center[icenter][1]
            upoint1, upoint2 = self.center[iupper][0], self.center[iupper][1]
            """Вычисляем вектор,проведённый из нижнего нейтрального в центр центрального позвонка"""
            vect_x = cpoint1 - dpoint1  # a1
            vect_y = cpoint2 - dpoint2  # a2
            """Вычисляем вектор,проведённый из центра центрального позвонка в центр верхнего позвонка"""
            vect_xx = upoint1 - cpoint1  # b1
            vect_yy = upoint2 - cpoint2  # b2
            """Высчитываем угол между двумя этими векторами"""
            cos = vect_x * vect_xx + vect_y * vect_yy
            cos2 = math.sqrt(vect_x * vect_x + vect_y * vect_y) * math.sqrt(vect_xx * vect_xx + vect_yy * vect_yy)
            angle = math.acos(cos / cos2)
            if angle > pi / 2:
                angle = pi - angle
            print('angle = ', angle, angle * 180 / pi)
            scoliosis_angle_list.append(angle * 180 / pi)
        self.scoliosis_angle_Fergusson = np.array(scoliosis_angle_list)

    def calculate_scoliosis_severity(self, angle_type='Kobb'):
        # Вычисление степени сколиоза
        # Вычисляется сумма углов сколиоза, по ним вычисляется степень
        pass
