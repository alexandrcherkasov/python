import numpy as np
import cv2 as cv
import sys
import math
import pylab
import matplotlib
import graphviz as gv


def to_fixed(self, digits=0):
    return f"{self:.{digits}f}"


def drawLine(c_im_x, c_im_y, c_im_x_max, c_im_y_max):
    """
    Рисование линии
    """
    x0 = c_im_x
    y0 = c_im_y

    x1 = c_im_x_max
    y1 = c_im_y_max

    line = matplotlib.lines.Line2D([x0, x1], [y0, y1], color="k")
    axes.add_line(line)


def plot(x_coord, y_coord, width, height, angles, marks, divergences):
    """
    Рисование повернутого прямоугольника
    """
    rect_coord = (x_coord, y_coord)
    rect_width = width
    rect_height = height
    rect_angle = angles
    recta = matplotlib.patches.Rectangle(rect_coord,
                                         rect_width,
                                         rect_height,
                                         rect_angle,
                                         color="g")
    axes.add_patch(recta)
    if marks == 1:
        pylab.text(x_coord - 20, y_coord + 10, divergences, horizontalalignment="center")
        pylab.text(x_coord - 25, y_coord + 10, "+", horizontalalignment="center")
        pylab.text(x_coord - 30, y_coord + 10, "Center", horizontalalignment="center")

        pylab.text(x_coord - 40, y_coord + 10, to_fixed(angles, 2), horizontalalignment="center")
        pylab.text(x_coord - 45, y_coord + 10, "+", horizontalalignment="center")
        pylab.text(x_coord - 50, y_coord + 10, "Angle", horizontalalignment="center")
    else:
        pylab.text(x_coord - 20, y_coord + 10, divergences, horizontalalignment="center")
        pylab.text(x_coord - 25, y_coord + 10, "-", horizontalalignment="center")
        pylab.text(x_coord - 30, y_coord + 10, "Center", horizontalalignment="center")

        pylab.text(x_coord - 40, y_coord + 10, to_fixed(angles, 2), horizontalalignment="center")
        pylab.text(x_coord - 45, y_coord + 10, "-", horizontalalignment="center")
        pylab.text(x_coord - 50, y_coord + 10, "Angle", horizontalalignment="center")

def write(txt_file_name, j, x, y, center_write, angle, check):
    """Формат записи"""
    f = open(txt_file_name, "a")
    if check == 1:
        a = "+"
    else:
        a = "-"
    f.write(a + str(angle))
    f.write("\n\n(Angle)\n\n")
    f.write(a + str(center_write))
    f.write("\n\n(Center_Write)\n\n")
    f.write(str(x) + " ")
    f.write(str(y) + " ")
    f.write("\n\n(X Y Z)\n\n")
    f.write("# " + str(j) + "\n\n\n\n")
    f.write("\n")
    f.close()


def reverse(txt_file_name):
    f = open(txt_file_name, "r")
    list = []
    for line in f:
        list.append(line)
    f.close()
    f = open(txt_file_name, "w")
    i = len(list)
    j = 0
    for k in range(i):
        f.write(list[i - k - 1])
    f.close()


img = cv.imread("test.png")
hsv = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
contours, hierarchy = cv.findContours(hsv, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
j = 7
"""Инициализация массивов"""
for i in range(len(contours)):
    size = len(contours)
    center_image_x = np.zeros(size)
    center_image_y = np.zeros(size)
    coord_x_1 = np.zeros(size)
    coord_y_1 = np.zeros(size)
    coord_xx_1 = np.zeros(size)
    coord_yy_1 = np.zeros(size)
    coord_xx_2 = np.zeros(size)
    coord_yy_2 = np.zeros(size)
"""Заполнение массива"""
for i in range(len(contours)):
    cnt_ = contours[i]
    rect_ = cv.minAreaRect(cnt_)
    center_, wh_, rot_ = rect_
    center_image_x[i] = int(center_[0])
    center_image_y[i] = int(center_[1])
"""Контуры снизу вверх 0-n"""
for i in range(len(contours)):
    cnt = contours[i]
    rect = cv.minAreaRect(cnt)
    box = cv.boxPoints(rect)
    center, wh, rot = rect
    box = np.int0(box)
    center = np.int0(center)
    rot = np.int0(rot)
    """Координаты центра первого позвонка по x"""
    first_center = center_image_x[0]
    first_center_y = center_image_y[0]
    """Координаты центров для сравнения"""
    bones_center = center_image_x[i]
    """Переменная для расчёта отклонения от центра"""
    divergence = 0
    """Определения знака отклонения"""
    mark = 0
    """Сравнение центров и определения отклоения"""
    if first_center < bones_center:
        divergence = bones_center - first_center
        mark = 1
    else:
        divergence = first_center - bones_center
        mark = 0
    coord_x_1[i] = center_image_x[i]
    coord_y_1[i] = center_image_y[i]
    coord_xx_1[i] = center_image_x[i]
    coord_yy_1[i] = coord_y_1[i] - 10
    """Координаты x/y первого вектора"""
    vector_1 = coord_xx_1[i] - coord_x_1[i]  # a1
    vector_2 = coord_yy_1[i] - coord_y_1[i]  # a2
    """-------------------------------"""
    coord_xx_2[i] = first_center
    coord_yy_2[i] = 0
    """Координаты x/y второго вектора"""
    vector_3 = coord_xx_2[i] - coord_x_1[i]  # b1
    vector_4 = coord_yy_2[i] - coord_y_1[i]  # b2
    """-------------------------------"""
    angle = (vector_1 * vector_3 + vector_2 * vector_4) / (
            math.sqrt(vector_1 * vector_1 + vector_2 * vector_2) * math.sqrt(
        vector_3 * vector_3 + vector_4 * vector_4))
    rad = math.acos(angle)
    rad_1 = rad * (180 / math.pi)
    print(rad_1)
    write('test.txt', j, center_image_x[i], center_image_y[i], divergence, rad_1, mark)
    blank_image = np.zeros((500, 500, 3), np.uint8)
    j = j + 1
    pylab.xlim(0, 1000)
    pylab.ylim(0, 1000)
    pylab.grid()
    pylab.gca().invert_yaxis()
    # Получим текущие оси
    axes = pylab.gca()
    axes.set_aspect("equal")
    if wh[0] <= wh[1]:
        plot(box[2][0], box[2][1], wh[1], wh[0], rad_1, mark, divergence)
        print("y coord wh[0]<wh[1]")
        print(box[2][1])
    else:
        plot(box[0][0], box[0][1], wh[0], wh[1], rad_1, mark, divergence)
        print("y coord")
        print(box[0][1])
drawLine(first_center, 1000, first_center, 0)
pylab.show()
reverse('test.txt')
cv.imshow("my_Img", img)
cv.waitKey()
cv.destroyAllWindows()
